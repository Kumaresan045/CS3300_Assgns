//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
@SuppressWarnings("unchecked")
public class MicroGen<R,A> implements GJVisitor<R,A> 
{

   // My additions
   String FinalCode = "";
   ClassInfo classinfo;
   Map<String, ClassStruct> classStructs = new HashMap<String, ClassStruct>();
   int tempCounter = 0;
   int labelCounter = 0;
   SpecialMap varToTemp = new SpecialMap(); // <var , temp id>
   String currentClass;
   String currentMethod;
   String methodCode = "";

   public MicroGen(ClassInfo classinfo)
   {
      this.classinfo = classinfo;
      varToTemp.init(classinfo);
      initClassStructs();
      //structsDisplay();
   }

   public void structsDisplay()
   {
      for(String className : classStructs.keySet())
      {
         System.out.println("Class Name: " + className);
         ClassStruct cs = classStructs.get(className);
         System.out.println("Entries: ");
         for(String entry : cs.entries) System.out.println("    " + entry);
         System.out.println("TypesOfEntries: ");
         for(String entry : cs.typesOfEntries) System.out.println("    " + entry);
         System.out.println("VTable: ");
         for(String entry : cs.vtable) System.out.println("    " + entry);
         System.out.println("____________________________");
      }
   }

   public void getcode()
   {
      System.out.println(FinalCode);
   }

   void setCurrentClass(String className)
   {
      varToTemp.setCurrentClass(className);
      currentClass = className;
   }

   void setCurrentMethod(String methodName)
   {
      varToTemp.setCurrentMethod(methodName);
      currentMethod = methodName;
   }

   String getCurrentClass()
   {
      return varToTemp.getCurrentClass();
   }

   String getCurrentMethod()
   {
      return varToTemp.getCurrentMethod();
   }


   void initClassStructs()
   {
      for(String className : classinfo.classMap.keySet())
      {
         if(classStructs.containsKey(className)) continue;

         String parent = classinfo.classMap.get(className).parent;
         initClassStruct(className, parent);
      }
   }

   void initClassStruct(String className, String parent)
   {
      if(parent == null)
      {
         ClassStruct cs = new ClassStruct();
         cs.name = className;
         ClassData cd = classinfo.classMap.get(className);
         cs.entries.add("v_table");
         cs.typesOfEntries.add("v_table");
         for(String fieldName : cd.fields.keySet()) 
         {
            cs.entries.add(className + "_Kums_" + fieldName);
            cs.typesOfEntries.add(cd.fields.get(fieldName));
         }
         for(String methodName : cd.methods.keySet()) cs.vtable.add(className + "_Kums_" + methodName);
         classStructs.put(className, cs);
         return;
      }

      if(!classStructs.containsKey(parent)) 
         initClassStruct(parent, classinfo.classMap.get(parent).parent);

      ClassStruct cs = new ClassStruct();
      cs.name = className;
      ClassData cd = classinfo.classMap.get(className);
      ClassStruct parentCS = classStructs.get(parent);
      for(int i=0; i<parentCS.entries.size(); i++)        cs.entries.add(parentCS.entries.get(i));
      for(int i=0; i<parentCS.typesOfEntries.size(); i++) cs.typesOfEntries.add(parentCS.typesOfEntries.get(i)); 
      for(String fieldName : cd.fields.keySet())
      {
         cs.entries.add(className + "_Kums_" + fieldName);
         cs.typesOfEntries.add(cd.fields.get(fieldName));
      }
      for(int i=0; i<parentCS.vtable.size(); i++)  cs.vtable.add(parentCS.vtable.get(i));

      for(String methodName : cd.methods.keySet())
      {
         if(methodOverrideCheck(parent, methodName))
         {
            int index = getOverrideIndex(parent, methodName); 
            cs.vtable.set(index, className + "_Kums_" + methodName);
         }
         else cs.vtable.add(className + "_Kums_" + methodName);
      }
      classStructs.put(className, cs);
   }

   boolean methodOverrideCheck(String parent, String methodName)
   {
      if(parent == null) return false;
      if(!classStructs.containsKey(parent)) return false;
      ClassStruct cs = classStructs.get(parent);
      if(cs.vtable.contains(parent + "_Kums_" + methodName)) return true;
      parent = classinfo.classMap.get(parent).parent;
      return methodOverrideCheck(parent, methodName);
   }

   int getOverrideIndex(String className, String methodName)
   {
      ClassStruct cs = classStructs.get(className);
      if(cs.vtable.contains(className + "_Kums_" + methodName)) return cs.vtable.indexOf(className + "_Kums_" + methodName);
      String parent = classinfo.classMap.get(className).parent;
      return getOverrideIndex(parent, methodName);
   }

   String getBaseName(String name)
   {
      int index = name.indexOf("_Kums_");
      if(index == -1) return name;
      return name.substring(index+6);
   }

   String genPrint(int tempInd)
   {
      return "PRINT TEMP " + Integer.toString(tempInd) + "\n";
   }

   String genMov(int tempLHS, int tempRHS)
   {
      return "MOVE TEMP " + Integer.toString(tempLHS) + " TEMP " + Integer.toString(tempRHS) + "\n";
   }

   String genAllocate(int tempIND)
   {
      String code = "MOVE TEMP " + Integer.toString(tempCounter) + " PLUS TEMP " + tempIND + " 1\n"; 
      code += "MOVE TEMP " + Integer.toString(tempCounter+1) + " TIMES TEMP " + tempCounter + " 4\n";
      tempCounter++;
      code += "MOVE TEMP " + Integer.toString(tempCounter + 1) + " HALLOCATE TEMP " + tempCounter + "\n";
      int retTemp = tempCounter + 1;
      tempCounter+=2;
      code += "HSTORE TEMP " + retTemp + " 0 TEMP " + tempIND + "\n";
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " TIMES TEMP " + tempIND + " 4\n";
      int totSize = tempCounter-1;
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " PLUS TEMP " + retTemp + " TEMP " + totSize + "\n";
      int boundaryAddr = tempCounter-1;
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " PLUS TEMP " + retTemp + " 4\n";
      int iter = tempCounter-1;
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " LE TEMP " + iter + " TEMP " + boundaryAddr + "\n";
      int codn = tempCounter-1;
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " 0\n";
      int zero = tempCounter-1;
      code += "L" + Integer.toString(labelCounter++) + " NOOP\n";
      int begin = labelCounter-1;
      code += "CJUMP TEMP " + codn + " L" + Integer.toString(labelCounter++) + "\n";
      int end = labelCounter-1;
      code += "HSTORE TEMP " + iter + " 0 TEMP " +  zero + "\n";
      code += "MOVE TEMP " + iter + " PLUS TEMP " + iter + " 4\n";
      code += "MOVE TEMP " + codn + " LE TEMP " + iter + " TEMP " + boundaryAddr + "\n";
      code += "JUMP L" + begin + "\n";
      code += "L" + end + " NOOP\n";
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " TEMP " + retTemp + "\n";
      return code;
   }

   String genClassStruct(String className)
   {
      String code = "";
      ClassStruct cs = classStructs.get(className);
      int retStore = tempCounter++;
      code += "MOVE TEMP " + retStore + " HALLOCATE " + Integer.toString(cs.entries.size() * 4) + "\n";

      // Init Vtable
      int vtableStore = tempCounter++;
      code += "MOVE TEMP " + vtableStore + " HALLOCATE " + Integer.toString(cs.vtable.size() * 4) + "\n";
      for(int i=0; i<cs.vtable.size(); i++)
      {
         code += "MOVE TEMP " + Integer.toString(tempCounter) + " " + cs.vtable.get(i) + "\n";
         code += "HSTORE TEMP " + vtableStore + " " + Integer.toString(i*4) + " TEMP " + Integer.toString(tempCounter) + "\n";
         tempCounter++;
      }

      code += "HSTORE TEMP " + retStore + " 0 TEMP " + Integer.toString(vtableStore) + "\n";
      
      if(cs.entries.size() > 1)
      {
         int zero = tempCounter++;
         code += "MOVE TEMP " + zero + " 0\n";
         
         // Init Class Entries to 0
         for(int i=1; i<cs.entries.size(); i++) 
            code += "HSTORE TEMP " + retStore + " " + Integer.toString(i*4) + " TEMP " + zero + "\n";
      }
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " TEMP " + retStore + "\n";
      return code;
   }

   String genNot(int tempInd)
   {
      String code = "MOVE TEMP " + Integer.toString(tempCounter) + " MINUS 1 TEMP " + Integer.toString(tempInd) + "\n";
      tempCounter++;
      return code;
   }

   String genAnd(int arg1, int arg2, String codeRHS)
   {
      int firstFalse = labelCounter++;
      String code = "CJUMP TEMP " + Integer.toString(arg1) + " L" + Integer.toString(firstFalse) + "\n";
      code += codeRHS;
      code += "CJUMP TEMP " + Integer.toString(arg2) + " L" + Integer.toString(firstFalse) + "\n";
      int retTemp = tempCounter++;
      code += "MOVE TEMP " + Integer.toString(retTemp) + " 1\n";
      int end = labelCounter++;
      code += "JUMP L" + Integer.toString(end) + "\n";
      code += "L" + Integer.toString(firstFalse) + " NOOP\n";
      code += "MOVE TEMP " + Integer.toString(retTemp) + " 0\n";
      code += "L" + Integer.toString(end) + " NOOP\n";

      return code;
   }

   String genOR(int arg1, int arg2, String codeRHS)
   {
      int firstFalse = labelCounter++;
      String code = "CJUMP TEMP " + Integer.toString(arg1) + " L" + Integer.toString(firstFalse) + "\n";
      int secondFalse = labelCounter++;
      int retTemp = tempCounter++;
      int end = labelCounter++;
      code += "MOVE TEMP " + Integer.toString(retTemp) + " 1\n";
      code += "JUMP L" + Integer.toString(end) + "\n";
      code += "L" + Integer.toString(firstFalse) + " NOOP\n";
      code += codeRHS;
      code += "CJUMP TEMP " + Integer.toString(arg2) + " L" + Integer.toString(secondFalse) + "\n";
      code += "MOVE TEMP " + Integer.toString(retTemp) + " 1\n";
      code += "JUMP L" + Integer.toString(end) + "\n";
      code += "L" + Integer.toString(secondFalse) + " NOOP\n";
      code += "MOVE TEMP " + Integer.toString(retTemp) + " 0\n";
      code += "L" + Integer.toString(end) + " NOOP\n";

      return code;
   }

   String genBinOP(int arg1, int arg2, String Op)
   {
      String code = "MOVE TEMP " + Integer.toString(tempCounter) + " " + Op + " TEMP " + Integer.toString(arg1) + " TEMP " + Integer.toString(arg2) + "\n";
      tempCounter++;
      return code;
   }

   String genArrLoad(int arrTemp, int indexTemp)
   {
      String code = "MOVE TEMP " + Integer.toString(tempCounter++) + " PLUS TEMP " + indexTemp + " 1\n";
      int offOne = (tempCounter-1);
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " TIMES TEMP " + Integer.toString(offOne) + " 4\n";
      int actualInd = tempCounter-1;
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " PLUS TEMP " + Integer.toString(arrTemp) +  " TEMP " + Integer.toString(actualInd) + "\n";
      int offsetAddr = tempCounter-1;
      code += "HLOAD TEMP " + Integer.toString(tempCounter++) + " TEMP " + Integer.toString(offsetAddr) + " 0\n";
      return code;
   }

   String genMethodCall(String classObjName, String classID, String methodName, Vector<String> args)
   {
      Vector<String> vtable = classStructs.get(classObjName).vtable;
      String methodIndx = "Not Declared";
      String methodID = "Not Declared";
      for(int i=0; i<vtable.size(); i++)
      {
         if(getBaseName(vtable.get(i)).equals(methodName)) methodIndx = Integer.toString(i*4);
      }
      String code = "HLOAD TEMP " + tempCounter + " TEMP " + classID + " 0\n";
      int vtableIndx = tempCounter++;
      code += "HLOAD TEMP " + tempCounter + " TEMP " + vtableIndx + " " + methodIndx + "\n";
      methodID = Integer.toString(tempCounter++);

      String retTemp = Integer.toString(tempCounter++);
      code += "MOVE TEMP " + retTemp + " CALL TEMP " + methodID + " ( TEMP " + classID + " ";
      for(String arg : args)
         code += "TEMP " + arg + " ";
      code += ")\n";
      return code;
   }

   String genArrLength(int arrTemp)
   {
      String code = "HLOAD TEMP " + Integer.toString(tempCounter) + " TEMP " + Integer.toString(arrTemp) + " 0\n";
      tempCounter++;
      return code;
   }

   String genArrAssign(int arrTemp, int indexTemp, int valTemp)
   {
      String code = "MOVE TEMP " + Integer.toString(tempCounter++) + " PLUS TEMP " + indexTemp + " 1\n";
      int offOne = (tempCounter-1);
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " TIMES TEMP " + Integer.toString(offOne) + " 4\n";
      int actualInd = tempCounter-1;
      code += "MOVE TEMP " + Integer.toString(tempCounter++) + " PLUS TEMP " + Integer.toString(arrTemp) + " TEMP " + Integer.toString(actualInd) + "\n";
      int actualAddr = tempCounter-1;
      code += "HSTORE TEMP " + Integer.toString(actualAddr) + " 0 TEMP " + Integer.toString(valTemp) + "\n";
      return code;
   }

   String genIfElse(int boolInd, String codeTrue, String codeFalse)
   {
      String code = "CJUMP TEMP "+ boolInd + " L" + labelCounter + "\n";
      int falseLab = labelCounter++;
      code += codeTrue;
      code += "JUMP L" + labelCounter + "\n";
      int end = labelCounter++;
      code += "L" + falseLab + " NOOP\n";
      code += codeFalse;
      code += "L" + end + " NOOP\n";
      return code;
   }

   String genWhile(int boolInd, String loopbody, Expression expr)
   {
      String code = "L" + labelCounter + " NOOP\n";
      int loopLab = labelCounter++;
      code += "CJUMP TEMP " + boolInd + " L" + labelCounter + "\n";
      int end = labelCounter++;
      code += loopbody;
      code += (String) expr.accept(this,null);
      int exprInd = (tempCounter-1);
      code += "MOVE TEMP " + boolInd + " TEMP " + exprInd + "\n";
      code += "JUMP L" + loopLab + "\n";
      code += "L" + end + " NOOP\n";
      return code;
   }

   String genDoWhile(int boolInd, String doStat , Expression expr)
   {
      String code = "L" + labelCounter + " NOOP\n";
      int loopLab = labelCounter++;
      code += doStat;
      code += (String) expr.accept(this,null);
      int exprInd = (tempCounter-1);
      code += "MOVE TEMP " + boolInd + " TEMP " + exprInd + "\n";
      code += "CJUMP TEMP " + boolInd + " L" + labelCounter + "\n";
      int end = labelCounter++;
      code += "JUMP L" + loopLab + "\n";
      code += "L" + end + " NOOP\n";
      return code;
   }

   String genMethod(String methodName, NodeListOptional stmtStar, Expression retExpr)
   {
      ClassData cd = classinfo.classMap.get(currentClass);
      MethodData md = cd.methods.get(methodName);
      int noOfArgs = md.argnames.size(); 
      String code = "\n" + currentClass + "_Kums_" + methodName + " [" + Integer.toString(noOfArgs+1) + "]\nBEGIN\n";
      int noOfDecls = md.methodDecls.size();
      tempCounter = noOfArgs + noOfDecls + 1;
      for(Node nod : stmtStar.nodes)
      {
         Statement stmt = (Statement) nod;
         code += (String) visit(stmt,null);
      }
      code += (String) visit(retExpr,null);
      int retInd = tempCounter-1;
      code += "RETURN TEMP " + Integer.toString(retInd) + "\nEND\n";
      tempCounter = 0;
      return code;
   }

   String genFetch(String var)
   {
      String tempIDOfVar = varToTemp.getTempid(var);
      String code = "";
      if(tempIDOfVar == null)
      {
         ClassStruct cs = classStructs.get(currentClass);
         int entrySize = cs.entries.size();
         for(int indx = entrySize -1 ; indx > 0; indx--)
         {
            String field = getBaseName(cs.entries.get(indx));
            if(var.equals(field))
            {
               indx*=4;
               tempIDOfVar = Integer.toString(indx);
               code += "HLOAD TEMP " + Integer.toString(tempCounter++) + " TEMP 0 " + tempIDOfVar + "\n"; 
               break;
            }
         }
      }
      else code += "MOVE TEMP " + Integer.toString(tempCounter++) + " TEMP " + tempIDOfVar + "\n";
      return code;
   }

   String genAssign(String var, String tempId)
   {
      String tempIDOfVar = varToTemp.getTempid(var);
      String code = "";
      if(tempIDOfVar == null)
      {
         ClassStruct cs = classStructs.get(currentClass);
         int entrySize = cs.entries.size();
         for(int indx = entrySize -1 ; indx > 0; indx--)
         {
            String field = getBaseName(cs.entries.get(indx));
            if(var.equals(field))
            {
               String offset = Integer.toString(indx * 4);
               code += "HSTORE TEMP 0 " + offset + " TEMP " + tempId + "\n"; 
               break;
            }
         }
      }
      else code += "MOVE TEMP " + tempIDOfVar + " TEMP " + tempId + "\n";
      return code;
   }

   String getclassType(String var)
   {
      String typ = varToTemp.getType(var);
      if(typ == null)
      {
         ClassStruct cs = classStructs.get(currentClass);
         int entrySize = cs.entries.size();
         for(int indx = entrySize -1 ; indx > 0; indx--)
         {
            String field = getBaseName(cs.entries.get(indx));
            if(var.equals(field))
            {
               typ = cs.typesOfEntries.get(indx);
               break;
            }
         }
      }
      return typ;
   }

   String getMethodRetType(String className, String methodName)
   {
      ClassData cd = classinfo.classMap.get(className);
      MethodData md = cd.methods.get(methodName);
      if(md == null)
      {
        String parent = cd.parent;
         if(parent != null)
         {
            return getMethodRetType(parent,methodName);
         }
         else return null;
      }
      return md.returntype;
   }

//=======================================================================================================//
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n, A argu) {
      R _ret=null;
      //int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         //_count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         //int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            //_count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      //int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         //_count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n, A argu) 
   {
      R _ret=null;
      String maincode = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      FinalCode = "MAIN\n" + maincode + "END\n";
      FinalCode+= methodCode;
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n, A argu) 
   {
      setCurrentClass("*MainClass*");
      setCurrentMethod("Main");
      R _ret=null;
      String code = (String) n.f14.accept(this, argu);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n, A argu) {
      R _ret=null;
      setCurrentClass(n.f1.f0.tokenImage);
      n.f4.accept(this,argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n, A argu) {
      R _ret=null;
      setCurrentClass(n.f1.f0.tokenImage);
      n.f6.accept(this,argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n, A argu) {
      R _ret=null;
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n, A argu) {
      R _ret=null;
      String methodName = n.f2.f0.tokenImage;
      setCurrentMethod(methodName);
      methodCode += genMethod(methodName, n.f8, n.f10);
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n, A argu) {
      R _ret=null;
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) {
      R _ret=null;
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) {
      R _ret=null;
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n, A argu) {
      R _ret=null;
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | DoStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n, A argu) 
   {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {

      NodeListOptional stmtlist = n.f1;
      String code = "";
      for(Node node : stmtlist.nodes)
      {
         Statement stmt = (Statement)node;
         code += stmt.accept(this, argu);
      }
      return (R)code;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
      R _ret=null;
      String code = (String) n.f2.accept(this, argu);
      String id = n.f0.f0.tokenImage;
      String TempOfId = Integer.toString(tempCounter-1);
      code += (String) genAssign(id,TempOfId);
      _ret = (R)code;
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
      R _ret=null;
      String code = "";
      String var = n.f0.f0.tokenImage;
      code += genFetch(var);
      int arrTemp = tempCounter - 1;
      code += (String) n.f2.accept(this, argu);
      int indexTemp = tempCounter-1;
      code += (String) n.f5.accept(this, argu);
      int valueTemp = tempCounter-1;
      code += genArrAssign(arrTemp, indexTemp, valueTemp);
      _ret = (R)code;
      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
      R _ret=null;
      String code = (String) n.f2.accept(this, argu);
      int boolTemp = tempCounter-1;
      String codeTrue = (String) n.f4.accept(this, argu);
      code += genIfElse(boolTemp, codeTrue, "NOOP\n");
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) {
      R _ret=null;
      String code = (String) n.f2.accept(this, argu);
      int boolTemp = tempCounter-1;
      String codeTrue = (String) n.f4.accept(this, argu);
      String codeFalse = (String) n.f6.accept(this, argu);
      code += genIfElse(boolTemp, codeTrue, codeFalse);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) {
      R _ret=null;
      String code = (String) n.f2.accept(this, argu);
      int boolTemp = tempCounter-1;
      String loopbody = (String) n.f4.accept(this, argu);
      code += genWhile(boolTemp, loopbody, n.f2);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> "do"
    * f1 -> Statement()
    * f2 -> "while"
    * f3 -> "("
    * f4 -> Expression()
    * f5 -> ")"
    * f6 -> ";"
    */
   public R visit(DoStatement n, A argu) {
      R _ret=null;
      String doStat = (String) n.f1.accept(this, argu);
      String code = (String) n.f4.accept(this, argu);
      int boolTemp = tempCounter-1;
      code += genDoWhile(boolTemp, doStat, n.f4);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) {
      R _ret=null;
      String code = (String) n.f2.accept(this, argu);
      code+= genPrint(tempCounter-1);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | AddExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) 
   {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n, A argu) {
      R _ret=null;
      String codeLHS = (String) n.f0.accept(this, argu);
      int arg1 = (tempCounter-1);
      String codeRHS = (String) n.f2.accept(this, argu);
      int arg2 = (tempCounter-1);
      String code = genAnd(arg1, arg2, codeRHS);
      code = codeLHS + code;
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public R visit(OrExpression n, A argu) {
      R _ret=null;
      String codeLHS = (String) n.f0.accept(this, argu);
      int arg1 = (tempCounter-1);
      String codeRHS = (String) n.f2.accept(this, argu);
      int arg2 = (tempCounter-1);
      String code = genOR(arg1, arg2, codeRHS);
      code = codeLHS + code;
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      int arg1 = tempCounter-1;
      code += (String) n.f2.accept(this, argu);
      int arg2 = tempCounter-1;
      code += genBinOP(arg1,arg2,"LE");
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public R visit(neqExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      int arg1 = tempCounter-1;
      code += (String) n.f2.accept(this, argu);
      int arg2 = tempCounter-1;
      code += genBinOP(arg1,arg2,"NE");
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(AddExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      int arg1 = tempCounter-1;
      code += (String) n.f2.accept(this, argu);
      int arg2 = tempCounter-1;
      code += genBinOP(arg1,arg2,"PLUS");
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      int arg1 = tempCounter-1;
      code += (String) n.f2.accept(this, argu);
      int arg2 = tempCounter-1;
      code += genBinOP(arg1,arg2,"MINUS");
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      int arg1 = tempCounter-1;
      code += (String) n.f2.accept(this, argu);
      int arg2 = tempCounter-1;
      code += genBinOP(arg1,arg2,"TIMES");
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public R visit(DivExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      int arg1 = tempCounter-1;
      code += (String) n.f2.accept(this, argu);
      int arg2 = tempCounter-1;
      code += genBinOP(arg1,arg2,"DIV");
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      int arg1 = tempCounter-1;
      code += (String) n.f2.accept(this, argu);
      int arg2 = tempCounter-1;
      code += genArrLoad(arg1,arg2);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      int arrTemp = tempCounter-1;
      code += genArrLength(arrTemp);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n, A argu) 
   {
      R _ret=null;
      Vector<String> listOfTemps = new Vector<String>();
      StringContainer classType = new StringContainer("");
      String code = (String) n.f0.accept(this, (A)classType);
      String classObjName = classType.getString();
      String classObjTemp = Integer.toString(tempCounter-1);

      //Iterating thru ExpressionList
      NodeOptional nodeopt = n.f4;
      if(nodeopt.present())
      {
         ExpressionList exprlist = (ExpressionList)nodeopt.node;
         code += exprlist.f0.accept(this, argu);
         String tempOfArg = Integer.toString(tempCounter-1);
         listOfTemps.add(tempOfArg);

         NodeListOptional exprlistrest = exprlist.f1;
         if(exprlistrest.present())
         {
            for(Node node : exprlistrest.nodes)
            {
               ExpressionRest exprrest = (ExpressionRest)node;
               code += exprrest.f1.accept(this, argu);
               tempOfArg = Integer.toString(tempCounter-1);
               listOfTemps.add(tempOfArg);
            }
         }
      }

      String method = n.f2.f0.tokenImage;
      String methodRetType = getMethodRetType(classObjName,method);
      code += genMethodCall(classObjName,classObjTemp,method,listOfTemps);

      StringContainer classTypeFromUp = (StringContainer) argu;
      if(classTypeFromUp!=null) classTypeFromUp.setString(methodRetType);
      _ret = (R) code;

      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n, A argu) {
      R _ret=null;
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n, A argu) {
      R _ret=null;
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f0.accept(this, argu);
      StringContainer classType = (StringContainer) argu;
      if(code == null) 
      {
         int whichchoice = n.f0.which;
         if(whichchoice == 3)
         {
            Identifier id = (Identifier) n.f0.choice;
            if(classType!=null) classType.setString(getclassType(id.f0.tokenImage));
            code = genFetch(id.f0.tokenImage);
         }
         if(whichchoice == 4)
         {
            code = genMov(tempCounter++, 0);
            if(classType!=null) classType.setString(currentClass);
         }
      }
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      String code = "MOVE TEMP " + Integer.toString(tempCounter++) + " " + n.f0.tokenImage + "\n";
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) {
      R _ret=null;
      String code = "MOVE TEMP " + Integer.toString(tempCounter++) + " 1\n";
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n, A argu) {
      R _ret=null;
      String code = "MOVE TEMP " + Integer.toString(tempCounter++) + " 0\n";
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n, A argu) {
      R _ret=null;
      // Ask Parent -> Too many productions use this visit
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n, A argu) {
      R _ret=null;
      // Passed as argument -> MOV TEMP k TEMP 0
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f3.accept(this, argu);
      int tempExp = tempCounter - 1;
      code += genAllocate(tempExp); 
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n, A argu) {
      R _ret=null;
      String className = n.f1.f0.tokenImage;
      _ret = (R) genClassStruct(className);
      StringContainer classtype = (StringContainer) argu;
      if(classtype!=null) classtype.setString(className);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String code = (String) n.f1.accept(this, argu);
      code += genNot(tempCounter-1);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n, A argu) {
      R _ret=null;
      String code = (String) n.f1.accept(this, argu);
      _ret = (R) code;
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public R visit(IdentifierList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public R visit(IdentifierRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

}

class Pair
{
   public String first = "";
   public String second = "";
}

class SpecialMap
{
   Map<String, Map <String, Map <String, Pair> >> classes;
   String currentClass;
   String currentMethod;

   SpecialMap()
   {
      classes = new HashMap<String, Map <String, Map <String, Pair> >>();
      currentClass = null;
      currentMethod = null;
   }

   void init(ClassInfo classinfo)
   {
      for(String className : classinfo.classMap.keySet())
      {
         currentClass = className;
         ClassData cd = classinfo.classMap.get(className);
         for(MethodData md : cd.methods.values())
         {
            currentMethod = md.methodname;
            int i = 1;
            for(int j=0; j< md.argnames.size(); j++)
            {
               String paramName = md.argnames.get(j);
               Pair pair = new Pair();
               pair.first = Integer.toString(i);
               pair.second = md.argtypes.get(j);
               this.add(paramName, pair.first, pair.second);
               i++;
            }
            for(String methodDecl : md.methodDecls.keySet())
            {
               String typeOfMethodDecl = md.methodDecls.get(methodDecl); 
               this.add(methodDecl, Integer.toString(i), typeOfMethodDecl);
               i++;
            }
         }
      }
      currentClass = null;
      currentMethod = null;
   }

   void add(String key, String val, String typeOfval)
   {
      Map <String , Map <String, Pair> > methods = classes.get(currentClass);
      if(methods == null)
      {
         methods = new HashMap<String, Map <String, Pair> >();
         classes.put(currentClass, methods);
      }
      Map <String, Pair> vars = methods.get(currentMethod);
      if(vars == null)
      {
         vars = new HashMap<String, Pair>();
         methods.put(currentMethod, vars);
      }
      Pair pair = new Pair();
      pair.first = val;
      pair.second = typeOfval;
      vars.put(key, pair);
   }

   String getTempid(String key)
   {
      Map <String , Map <String, Pair> > methods = classes.get(currentClass);
      if(methods == null) return null;
      Map <String, Pair> vars = methods.get(currentMethod);
      if(vars == null || vars.get(key) == null) return null;
      return vars.get(key).first;
   }

   String getType(String key)
   {
      Map <String , Map <String, Pair> > methods = classes.get(currentClass);
      if(methods == null) return null;
      Map <String, Pair> vars = methods.get(currentMethod);
      if(vars == null || vars.get(key) == null) return null;
      return vars.get(key).second;
   }

   void setCurrentClass(String className)
   {
      currentClass = className;
   }

   void setCurrentMethod(String methodName)
   {
      currentMethod = methodName;
   }

   String getCurrentClass()
   {
      return currentClass;
   }

   String getCurrentMethod()
   {
      return currentMethod;
   }

   void display()
   {
      System.out.println("Displaying the VarToId Map : ");
      for(String className : classes.keySet())
      {
         System.out.println("Class : " + className);
         String indent = "     ";
         for(String methodName : classes.get(className).keySet())
         {
            System.out.println(indent + "Method : " + methodName);
            for(String var : classes.get(className).get(methodName).keySet()) 
               System.out.println(indent + indent + "Var : " + var + " :: " + "( Tid : " +  classes.get(className).get(methodName).get(var).first + " , Type : " + classes.get(className).get(methodName).get(var).second + " )");
         }
      }
      System.out.println("Displaying Done");
   }
}

class StringContainer
{
   String val = "";
   StringContainer(String val)
   {
      this.val = val;
   }
   String getString()
   {
      return val;
   }
   void setString(String val)
   {
      this.val = val;
   }
}